## React behind scenes

- Its a JS library for building UI. React works with components.
- It manages component composition & state. 
- To bring real HTML elements to a DOM, we need ReactDOM.
- ReactDOM is the interface to web and it handles what user sees.
- ReactDOM receives the difference and manipulates real DOM.
- Whenever props/state/context changes, react re-renders to update itself. It lets reactDOM know.
- Re-evaluating components doesnt mean re-rendering DOM.
- Only the delta between the snapshots are rendered to DOM ( virtual DOM diff )
- If we put a console, we see that the whole component is re-rendered, but only those delta is changed in real DOM ( open chrome console > More tools > rendering > enable Paint flashing )
- When parent changes, all of its children too is re-rendered though its prop isnt changed.
- We need to tell, that only if the input prop changes, the component is re-evaluated.

## Prevent unnecessary re-render

- Wrap the child component with `React.memo` for functional components to prevent unnecessary component re-evaluations.
- Only when the value of the prop changes, the component is re-evaluated.
- The prop , if its a function, it will re-render though. ( eg: onClick ). Component is just a function. So the function passed is getting re-created.
- There are trade offs in performance. If we can cut off entire-branches, its worth trying. 
- No point in using memo if we know that the props will re-render pretty much every time.
`hi === hi` and `true === true` but 2 functions / reference types, won't be equal.
- For functions, we can use `useCallback`
- It re-executes again & again when state changes. So functions are recreated again & again.
- Similarly, if the prop is an array or an object, this will re-execute again.
- Primitive values will work with the memo comparison.
- Two function will never be equal.
- We have a User component which is wrapped with Memo
- It's useful when we can cut off entire branches

```
const User = ({ user, onUserSelect }) => {
  useEffect(() => {
    console.log('User component init');
  });
}
export default React.memo(User);

And in App.js

 <User key={user.id} user={user} onUserSelect={handleUserSelect} />

```

This will still trigger the console even when any of the App state changes.
This is unnecessary. We need to tell react that the function should not be re-created
for every execution.

```
working example for useCallBack and useMemo
https://stackblitz.com/edit/react-ko8qqz?file=src/App.js
```

- To prevent function recreation, we have `useCallback` which is a hook that helps store a function across component executions.
- Store a function across component execution. Please dont recreate with every render.

- Optimization comes at a cost. So apply them appropriately.
- Place them at a high level , not on every component.
- If it can cut of entire branches, then its worth.
- The function which was passed down as prop will still change on every re-render as its re-created every time.
- React does a shallow comparison.
- We can prevent function recreation with useCallback().
- A function when passed as a prop, is a callback. What we say is, use the same callback, and do not create a second version of it ( unless some of its dependency changed.)

```
const handleClick = useCallback(() => {

}, [dependencyVariable]);

```

- Functions are closures. So we need to pass the dependency. When a function is defined, JS basically locks in all the variables used inside. Next time, this stored variable will be used. Changes to that variable wont be picked up.

## State updates

- Calling a state update schedules the state update. 
- It is not an instant change. React will eventually do it at a later point in time.
- It guarentees the order of state changes for one & same kind of states.
- Since multiple state updates can be scheduled together, use the function form to ensure that we act upon the latest snapshot every time.
- If there are multiple synchronous state updates in the same block of code, those are
  batched together., ie within same call back handler. 

## useMemo

- useCallback can be used to store function objects.
- For other kinds of data, we have something similar. - useMemo ( we memoize the result of calculations ).
- If there is logics within code that might be performance intensive, ie, sorting a list which has 10,000 items, we already have useCallback which can store function objects & rebuild them only when their inputs changed.

We can memoize result of expensive calculations.

```
const sortedList = useMemo(() => {
  return items.sort((a, b) => a - b);
}, [items]);
```

We use this far less often than useCallback. We memoize data far less often.
