# Routing

- Deep linking
- Client side routing.
- Its not changing pages, but swapping components within a placeholder.
- Only one HTML request initially, and change visible content later without changing HTML.
- Pages should never refresh. So a regular anchor tag wont work out as the state will be lost on page refresh.
  `<Link to="/"> Home </Link>`
- Link component / NavLink component.
- With `Switch`, if we only need to show one active route that match first.
- `exact` matches the full path and not just the start.
```
npm i react-router-dom@5
```

## Wiring up the routing.

In App.js,

```
import { Route, Switch, Redirect } from "react-router-dom";
import React from "react";
import Home from "@components/Home";
import Products from "@components/Products";
import { NavLink, Link } from "react-router-dom";
import ProductDetail from "@components/ProductDetail";

function App() {
  return (
    <div>
      <header>
        <nav>
          <ul>
            <li>
              <NavLink activeClassName="active" to="/home">
                Home
              </NavLink>
            </li>
            <li>
              <NavLink activeClassName="active" to="/products">
                Products
              </NavLink>
            </li>
          </ul>
        </nav>
      </header>


      <Switch>
        <Route path="/" exact>
          <Redirect to="/home" />
        </Route>
        <Route path="/home">
          <Home />
        </Route>
        <Route path="/products" exact>
          <Products />
        </Route>
        <Route path="/product-detail/:productId">
          <ProductDetail />
        </Route>
        <Route path="*"> 
         <NotFound/>
        </Route>
      </Switch>
    </div>
  );
}

export default App;

```

And in index.js, 
we activate router and unlock router features.

```
import { BrowserRouter } from "react-router-dom";
const app = (
    <BrowserRouter>
      <App />
    </BrowserRouter>
);
ReactDOM.render(app, document.getElementById("root"));
```

## Nested routes:

In any component, we can use Route component.

```
import React from "react";
import { Route } from "react-router-dom";

const Home = () => {
  return (
    <div>
      Home
      <Route path="/home/new-user">
        <p> Welcome! </p>
      </Route>
    </div>
  );
};

export default Home;
```

For this component, if the path matches the one mentioned, extra content is loaded.

## To extract the route params,

```
import React from "react";
import { useParams } from "react-router-dom";

const ProductDetail = () => {
  const params = useParams();
  return <div>ProductDetail {params.productId} </div>;
};

export default ProductDetail;
```

## Programmatic navigation

```
import { useHistory } from 'react-router-dom'
const history = useHistory();

history.push('/quotes')
history.replace('/login') // cant go back to previous page
```

## Prevent unwanted route transition 

```
import { Prompt } from 'react-router-dom'

<Prompt when={isEntering} message={() => 'Are you sure?'}>
```

## Query params

```
import { useHistory, useLocation } from 'react-router-dom';
const history = useHistory();
const location = useLocation();

history.push('/quotes?sort=' + isSortAscending ? 'asc' : 'desc')

To read the query params, 
const queryParams = new URLSearchParams(location.search);
const isAsc = queryParams.get('sort') === 'asc';

```

## Using nested routes

```
<Route path={`/quotes/${params.quoteId}`} exact>
   <div>
     <Link to={`/quotes/${params.quoteId}/comments`}>
       Load comments
     </Link>
   </div>
</Route>
```

## More flexible routing code 

```
import { useHistory, useLocation, useRouteMatch } from 'react-router-dom';
const match = useRouteMatch();

<Route path={`${match.path}/comments`}>
<Link to={`${match.url}/comments`}>

history.push({
  pathname: location.pathname,
  search: `?sort=asc`
})
```

## Upgrade to React router 6

`npm install react-router-rom@latest`

With v6, `Switch` doesnt exist. Instead it became `Routes`

```
<Routes>
 <Route path="/welcome" element={<Welcome/>} />
</Routes>
```

- Internal logic changed. We no longer need `exact`.
- To get the old behavior of matching paths at the start a wildcard, `/products/*` can be used as a post fix.
- Order of routes doesnt matter anymore.
- `activeClassName` was removed. `className={(navData) => navData.isActive ? 'active' : ''}`
- `<Redirect />` doesnt exist anymore. Instead, `<Navigate />` is used.

```
<Route path="/" element={<Navigate replace to="/welcome">} />
```
## For nested route, 

In main route, 
```
<Route path="/welcome/*" element={<Welcome/>} />
```

and in nested route, it renders `/welcome/new-user`
```
<Routes>
  <Route path="new-user" element={<h1> Hello </h1>} />
</Routes>
```
Similarly, the `<Link to="new-user"` would be relative as well.

## Another approach for nested routes

in main route definition,

```
<Routes>
 <Route path="/welcome" element={<Welcome/>}>
   <Route path="new-user" element={<h1> Hello </h1>} />
 <Route>
</Routes>

```
and to tell where it should be inserted,

```
import { Outlet } from 'react-router-dom'

<Outlet />
```

## for programmatic navigation

`useHistory` doesnt exist with v6
```
import { useNavigate } from 'react-router-dom'

const navigate = useNavigate();
navigate('/welcome', { replace: true })
navigate(1) // -1, -2 etc 
```

`Prompt` doesnt exist with v6.

