# Side Effects, Complex state management with reducers, App wide state with context


- Main job of react - Render the UI, react to user input, re-render UI.
- Evaluate , render jsx,
- manage state, props, react to user input.
- when state / prop changes, re-evaluate component

## Side effects

- API requests
- timeouts
- Browser storage

## useEffect hook

- Can be used to handle side effects. ( more complex ones where pieces of states always updates together. )
- App wide state can be done with Context.
- UseEffect is ran after the component evaluation is done 

## Side effects

- Render UI, react to user inputs, re-render UI
- An effect is something like an API call.
- Storing in local storage, intervals, timeouts.
- First component is evaluated, then useEffect runs.

```
Will trigger when a state change
useEffect(() => {});

Same as component did mount
useEffect(() => {

},[]);

Rerun when any of the dependencies change
useEffect(() => {

},[props])
```

- useEffect is there to handle side effects.

## Clean ups

- It runs before every new side effects execution, but not when component initializes for the first time.
- We can use the cleanup for things like debounce.

```
useEffect(() => {
  const id = setTimeout(() => {} , 2000);
 return () => {
   clearTimeout(id);
 }
},[props])
```

## useReducer

- Helps with state management
- When multiple state needs to be managed together.
- When we have state updates that depends on other state updates.
- We may use many slices with useState, rather we use the useReducer
- use it when we need to update state based on multiple other state.

```
const reducer = (state, action) {
  switch(action.type) {
    case A: 
      break;
    case B: 
       break;
    default:
    return state
  }
}
const [state, dispatch] = useReducer(reducerFn, initialState, initFn)
```

We can also create a `reducer.js` and cut paste the reducer logic into that file.

Note: When we pass deps, make sure its a property & not an object
Since, the useEffect runs when any of the property within the object changes, which may not be desirable.

## useState vs useReducer

- useState - single independant props
- useReducer - state updates have grouped proeprty that updates together

## React context ( App wide state )

If we start forwarding state to nested components, we can consider this alternative.

- As a shortcut, for consumers, copy from here.
- Consumer takes a child which is a function.

```
<AuthContext.Consumer>
    { // takes a child
        (context) => {
        return (

        );
      }
    }
</AuthContext.Consumer>
```

As a part of refactor, auth-context can wrap the whole logic
so that App.js is lean

```
import React, { useState } from 'react';

const AuthContext = React.createContext({
  isLoggedIn: false,
  toggle: () => {},
});

export const AuthContextProvider = (props) => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const onLogin = () => {
    setIsLoggedIn((prevLogin) => !prevLogin);
  };
  // create a state object
  const state = {
    isLoggedIn,
    toggle: onLogin,
  };
  return (
    <AuthContext.Provider value={state}>
      {props.children}
    </AuthContext.Provider>
  );
};

export default AuthContext;

```

and in App.js, we just use that component which encapsulates whole logic.

- Note: The value should be an object.
- So we no longer need props to be passed down the hierarchy.
- Rather, we use the context to get them from anywhere below the hierarchy.

```
import { AuthContextProvider } from './context/auth-context';

  return (
    <AuthContextProvider>
      <Header />
       ...
    </AuthContextProvider>
  );
```

- we use context when we need to pass state down to deeply nested copmponents.
- We dont need to forward data down the tree.

```
import { useContext } from 'react';
import AuthContext from './context';

export const App = () => {
  const ctx = useContext(AuthContext);
  // ctx.isLoggedIn, ctx.toggle()
}
```

## Is context a state management replacement?

It can be used for state managment across the whole app. But, limitations being,
context is not optimized for high freqency changes. Thats better done by redux.

eg: Authentication, Localization can be possible candidates for context

It doesnt give access to dev tools.

## Rules for hooks

- All hooks starts with "use"
- Only call hooks within react function components / custom hooks.
- Should not be used within class components
- Call them only at top level, not in block statements or nested functions.
- For useEffect, make sure, we provide deps.

## Forward refs

- If we have a method within a component that needs to be called from outside
  of it, we can use forwardRef.
- Shouldn't do that often.
- eg: calling focus from outside the component. ie, imperatively.

Within component, we have a method which can be called from outside.


and the activate is called from outside the component.
We cant just call the activate like that by putting ref on `<Input ref={inputRef}>`
and simply calling `inputRef.current.activate()` wont work.

`Function components cannot be given refs` error will be shown.

That's when we need to use the below hook.

useImperativeHandle - is another way of using the functionality imperatively.

- for a functional component, along with the props, we get ref as the second param
- The second param object should contain everything we can use from outside.
- To enable ref, we need to wrap the function with forwardRef
- That pretty much means, `its still a react component, but capable of being bound to a ref`.

- So within the Input component,

```
import React, { useRef, useImperativeHandle } from "react";

// Input component is now capable of being bound to a ref.

const Input = React.forwardRef((props, ref) => {
  const inputRef = useRef();
  const activate = () => {
    inputRef.current.focus();
  }
  useImperativeHandle(ref, () => {
    return {
      focus: activate, // focus is the externally available name
    };
  });
  return (
    <div>
      <label> {props.label} </label>
      <input ref={inputRef} name={props.name} />
    </div>
  );
});

export default Input;
  
```

we are exposing functionality from a component to its parent to be called
and used from the parent.

`inputRef.current.focus()` can be called on the parent and also if the parent
has a ref attached to the component `<Input ref={inputRef}> ` ( as below )

And in the parent component

```
import { useContext, useRef } from "react";
import Input from "./Input";

const User = (props) => {

  const usernameRef = useRef();
  const passwordRef = useRef();

  const activate = () => {
    usernameRef.current.focus();
  };
  const activatePswd = () => {
    passwordRef.current.focus();
  };

  return (
    <>
      <div>
        <Input ref={usernameRef}
        label="User Name" name="username" />
        <Input ref={passwordRef}
        label="Password" name="password" />
        <button onClick={activate}>
          focus
        </button>
        <button onClick={activatePswd}>
          focus pswd
        </button>
      </div>
    </>
  );
};

```

In theory, we need to trigger the focus method from outside by calling activate()
For edge cases like focus, scroll etc , we can use this as last resort.

## Using bind() to pre configure a function

`onRemove={someHandler.bind(null, item.id)}`

- Bind pre-configures a function for future exection & allow us to pre configure
  the argument that will be received when it is executed.
