# Class based components

- Modern way is with functional components.
- Previously, we had classes. Error boundaries requires class components. ( must )
- Prior to 16.8, we used class components to manage state & side effects.
- With hooks, we could use functional components everywhere.
- Class based components cannot use `react hooks`.
- Components - two ways of defining components.
- To get the props, we use `this.props` in a class based component.
- class component needs a `render()` method. ( which is equivalent to the return in a functional component)
- Class based component can work along with functional components.

```
import { Component } from 'react'

export default class Cart extends Component {

  constructor() {
      super()
    // state is always an object.
    this.state = {
      name : "",
      age : 10
    }
  }

  updateHandler = () => {
    const { userName } = this.props;

    this.setState(prevState => {
        return {
            name: userName
        }
    });
  }

  render() {
    const { name } = this.state;
    return (
      <div>
        <p> { name } </p>
        <button onClick={this.updateHandler}> Update </button>
      </div>
    )
  }
}

```

- Its just that this requires a mental model.
- We need to use "this" inside of the class.
- setState merges the state with existing state, whereas, useState overwrites the existing state.
- We need to use this.updateHandler.bind(this) if we use the non-arrow function syntax as shown below.

```
  updateHandler() {
    const { userName } = this.props;
    this.setState(prevState => {
        return {
            name: userName
        }
    });
  }
<button onClick={this.updateHandler.bind(this)}> Update </button>
```

- Note: Here we use the functional form of setState to make sure that updates are on the latest available state. The object form doesnt guarentee that.

## Lifecycle hooks

- componentDidMount() - good for API calls. Just will run once on initial load.
- componentDidUpdate(prevProps, prevState) - when component is re-evaluated
- componentWillUnmount() - good for clean ups.

```
componentDidUpdate(prevProps, prevState) {
  // else it goes into infinite loop.
  if(prevState.search !== this.state.search) {
    this.setState({
      ...
    })
  }
}
```

we replace these with the useEffect() with its various forms.
( empty deps, with deps, with clean up return )

## Context

With class based components, the only thing that is changed, is the way we use them.

- We cannot use `useContext`
- We can use the `<Context.Consumer>` syntax in both functional & class components since it is within JSX only.
- We can connect to **only one context**, within class based components.

```
class User extends Component {
  static contextType = UserContext;

  // this.context.users
}
```

- Start with functional components
- If we need error boundaries, use class based components.

## Error boundaries

- If there is errors we cannot prevent.
- eg: HTTP and server is offline.
- try / catch can be used with regular javascript.

ErrorBoundary.js component.

- not available in functional components
- triggers when one of the child components throw an error
- Not the entire app crashes, but we catch them and manage them elegantly.
- When we add `componentDidCatch` to a class bsed component, that component becomes an error boundary.
- Triggered when one of the child components trigger an error.

```
class ErrorBoundary extends Component {
  state = {
      error: null,
      message: ''
  }
  componentDidCatch(error) {
      this.setState({
          error: true,
          message: error.message
      })
  }
  render() {
    if(this.state.error){
        return <p> Some error </p>
    }
    return this.props.children;
  }
}
export default ErrorBoundary;
```

and can wrap around any components that can potentially throw an error.

```
<ErrorBoundary>
  <UsersList />
</ErrorBoundary>
```
