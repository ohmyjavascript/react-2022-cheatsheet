# Fragment, Portal, Ref

- Tools to solve more problems.
- JSX has limitation of having one root element. We can have adjacent root siblings by wrapping a fragment. So, the layouts wont be affected.

- We can have a wrapper element that returns `props.children`
- `<React.Fragment>` can be used.
- Or, we an also use empty tags `<> </>`

## Portals

- For things like Modals or Overlays, we would like to have them at the top most of the tree. Semantically, it should be an overlay and above everything else. For accessibility purpose, it can affect. A direct child of the body is preferrable.

Check the console and see where the model ended up in DOM. In index.html, we put a div with an ID of `backdrop`.

```
<div id="backdrop"></div>

ReactDOM.createPortal(<Backdrop onClick={props.onConfirm}/>, 
 document.querySelector('#backdrop');
)

```

- If we need to take elements out of the hierarchy, we use portal.

## Ref

- Aka references. Quite powerful. 
- They allow us to get direct access to DOM
- To just read the value, we can use Refs.
- With Refs, we setup a connection between the HTML element & JS code.
- "Something in HTML needs to be connected with something in code"
- `const nameRef = useRef()` and in HTML element, `<input ref={nameRef}/>`
- If we console, we see that a real DOM node element will be assigned to ref. We get an object with a current prop which holds the actual value.
- Do not use Refs to manipulate the DOM.
- If we just need to read the value, and dont plan to change anything, refs are fine. We wont be storing state anywhere.

So _nameRef.current.value_ will hold the value of the input. To reset the value.

- If the requirement is to just read the value, refs are better. Now, the input becomes
  an uncontrolled component as the element is not controlled by state any more.

```
 nameInputRef.current.value = ''; // not recommended
```

## Controlled vs Uncontrolled

- With ref, its uncontrolled. The value is not controlled by React.
- We dont feed data back into input.
