# State and events

- Declarative approach: We set the desired state, react takes care of rendering them in the UI.
- UI is a function of state.
- Component is just a function. So react needs to call the function to update them.
- updater function re-renders the component.
- The updater function is asynchronous.
- State is on a per-component instance for useState.
- We can add event listeners like onClick, onChange etc ( everything starts with 'on')
- `onClick={handleClick}`or `{(e) => handleClick(e)}`
- Do not execute by using paranthesis. That will be executed at start.
- React calls the component functions when the same is evaluated. Upon changes,
  the same needs to be re-evaluated & that's where we need to have state.
- Variable assignments will never trigger re-evaluations. 
- To tell react that certain parts of the application be re-rendered, we need state. And even if the component re-renders, the function is recreated, so it resets the values.
- We import `useState`
- Hooks should be called directly inside of the components at the top.
- `const [value, updaterFunction]= useState()`
- This variable is stored somewhere by react and keep tracks of it.
- So, when we update this variable, the component is re-rendered with the new value.
- updater function is async. So a state update is scheduled.
- Upon re-render, react keeps tracks of the state and wont be re-initialized
  and grabs the latest state
- State is on a per-component basis. 

## Lifting state:

When we need to share state to siblings, we may need to lift them to a level where the parent can share them to all the child components below. ( just as high as needed )

## Controlled vs Uncontrolled component

- We tie up the value to a state - That is controlled component. ( mostly presentation components / dumb components )
- The value is passed on to a parent component.
- Its received from the parent component
- Logic resides in parent component.
- Value & changes to the value reside in parent component.
- useState can take individual pieces, or an object, but we need to spread existing values
  and overwrite the ones we need.
- When state depends on previous state, we should use the functional syntax while updating state to ensure we always work with previous state.

```
const titleChangeHandler = (event) => {
  setUserInput((prevState) => {
    return {
      ...prevState,
      title: event.target.value
    }
  })
}

```
- This syntax guarentees that the state snapshot is always the updated latest one.
- Remember - state flows down, events flow up.
- We pass around pointer to function.
- For two way binding, we pass `value` and `onChange`

## key points

- We use `map()` to loop through collection.
- We need a unique key for each instance when looped over a collection.
- To output items conditionally,
- We can store JSX content in variables.
- In elements, we see flash when the DOM changes. 

## To conditionally show / hide item, we can use

```
{ isAvailable && <p> { message} </p> }
{ isAvailable ? <p> { message} </p> : <p> Sorry , out of stock! </p> }
```

## To add styles dynamically

```
<div style={{ height: barFilledHeight, backgroundColor: 'red'}}></div>
```